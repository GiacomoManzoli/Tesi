% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex
% !TEX spellcheck = it-IT

%**************************************************************
\chapter{Strumenti e tecnologie utilizzate}
\label{cap:strumenti-tecnologie}
%**************************************************************

Il contenuto di questo capitolo contiene una descrizione più dettagliata delle tecnologie e degli strumenti utilizzati per sviluppare l'applicativo oggetto dello stage.

Come anticipato nel precedente capitolo, si è scelto di utilizzare React Native come framework principale per lo sviluppo dell'applicazione, il che vincola la scelta di alcuni strumenti e tecnologie.

\section{React Native}

Trattandosi di un framework per la definizione di interfacce grafiche, React Native prevede di strutturare l'applicazione secondo \textit{compomenti}, ognuno dei quali viene definito combinando componenti standard offerti dalla libreria o altri componenti definiti dallo sviluppatore.

React Native infatti offre una serie di componenti basilari che permettono di definire l'interfaccia grafica dell'applicazione e che vengono poi tradotti in componenti nativi, questi componenti possono sia semplici come \texttt{View}, \texttt{Text} o \texttt{Image}, sia componenti più complessi come \texttt{TabBarIOS} o \texttt{MapView}.

Ogni componente di un'applicazione realizzata con React Native ha sempre due proprietà:
\begin{itemize}
\item \texttt{state}: un oggetto che contiene le informazioni riguardanti lo stato del componente, i cambiamenti fatti a questo oggetto prevedono il re-rendering dell'interfaccia grafica. Tipicamente viene utilizzato per memorizzare gli oggetti che contengono le informazioni da visualizzare sull'interfaccia grafica.
\item \texttt{props}: un oggetto che contiene le informazioni che il componente riceve dal componente che lo contiene, spesso consistono i dati di visualizzare o in delle funzioni di callback da invocare al verificarsi di determinati eventi. Tipicamente i campi dati di questo oggetto vengono considerati immutabili in modo da evitare \textit{side effect} indesiderati.
\end{itemize}

Questi due oggetti portano ad un pattern comune nella progettazione dei componenti detto \textit{Smart \& Dumb}, che prevede la divisione dei componenti in due categorie, quelli \textit{smart} che svolgono il ruolo di \textit{controller} dell'applicazione e quelli \textit{dumb} sono più simili a dei template.

Tipicamente un componente \textit{dumb} non ha un proprio stato e si limita a visualizzare i dati ricevuti mediante l'oggetto \texttt{props} o ad invocare delle callback al verificarsi di determinati eventi. In questo modo si ottengono dei componenti generici, indipendenti dall'applicazione che possono essere testati e riutilizzati facilmente.

Un componente \textit{smart} invece è tipicamente composto da più componenti, sia \textit{dumb} che \textit{smart}, ed è dotato di un proprio stato, i cui dati vengono passati ai componenti figli. Inoltre contiene la definizione delle funzioni che si occupano della gestione degli eventi.

Nel caso l'applicazione segua il design pattern Flux (§\ref{sec:flux}), i componenti \textit{smart} sono quelli che si occupano di recuperare lo stato dagli \textit{stores} e di creare le varie \textit{actions}.

Un altro pattern comune nelle applicazioni sviluppate con React Native è quello di definire un singolo componente per ogni file di codice che deve contenere tutto il codice del componente, sia quello riguardante la logica di funzionamento, sia quello riguardante la logica di layout.
Questo è reso possibile dal fatto che le informazioni riguardati lo stile sono definite come oggetti JavaScript e il layout viene definito utilizzando la sintassi JSX.

\subsection{La sintassi JSX}

La sintassi JSX permette di inserire all'interno del codice JavaScript alcuni pezzi di codice XML, che devono essere poi trasfomati in JavaScript normale per poter essere eseguiti.

Il vantaggio offerto da questa sintassi è quello di poter definire in modo dichiarativo come i vari componenti dell'applicazione si compongono tra loro, semplificando così la definizione dell'interfaccia grafica da parte del programmatore.

\begin{lstlisting}[language=JavaScript, caption=Esempio della sintassi JSX di React Native]
<View style={styles.container}>
  <Text style={styles.welcome}>
    Welcome to React Native!
  </Text>
  <Text style={styles.instructions}>
    To get started, edit index.ios.js
  </Text>
  <Text style={styles.instructions}>
    Press Cmd+R to reload,{'\n'}
    Cmd+D or shake for dev menu
  </Text>
</View>
\end{lstlisting}

Nel caso di React Native, la traduzione da JSX a JavaScript viene poi fatta dal \textit{packager} prima della compilazione dell'applicazione (§\ref{sec:packager}).

\subsection{Oggetti JavaScript per la definizione dello stile}

Come anticipato la definizione dello stile dei componenti di un'applicazione viene effettuato utilizzando degli oggetti JavaScript che hanno dei campi dati che ricordano le proprietà dei CSS.

Questa scelta è stata effettuata perché il team di sviluppo di React Native ha dovuto implementare un sistema che trasformi le proprietà CSS in attributi dei componenti nativi.

Nell'implementare questo sistema è stato scelto di utilizzare degli oggetti JavaScript al posto dei CSS puri perché, in questo modo vengono risolti alcuni problemi dei CSS, come la località dei nomi delle classi e la gestione delle variabili.
Inoltre, non è più necessario riferirsi ad una determinata classe CSS utilizzando una stringa, in quanto basta usare un campo dati di un oggetto JavaScript, evidenziando così eventuali errori riguardanti il nome della classe errato.

\begin{lstlisting}[language=JavaScript, caption=Esempio della definizione dello stile di un componente di React Native]
var styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  instructions: {
    textAlign: 'center',
    color: '#333333',
    marginBottom: 5,
  },
});
\end{lstlisting}

Le impostazioni delle stile sono analoghe a quelle offerte dai CSS ed includono alcune funzionalità che non sono ancora pienamente supportate nell'ambio web come il sistema di layout flexbox.
Questo sistema prevede che un componente dell'applicazione possa andare a modificare le dimensione dei componenti che contiene, in modo da occupare al meglio lo spazio disponibile e di allineare in vari modi i componenti contenuti.

\subsection{JavaScript ES6 e ES7}

Il codice JavaScript prodotto utilizzando React Native segue lo standard ES5 dal momento che è lo standard supportato dalla versione attuale di JavaScriptCore\footnote{JavaScriptCore è la virtual machine che interpreta il JavaScript a runtime.}.

Tuttavia è possibile utilizzare alcune funzionalità specifiche degli standard ES6 e ES7, come la destrutturazione degli oggetti e l'utilizzo delle classi, dal momento che il \textit{packager} di React Native (§\ref{sec:packager}), prima di compilare l'applicazione nativa, compila il codice JavaScritp utilizzando Babel\footnote{\url{https://babeljs.io/}}, un compilatore per JavaScript che trasforma la sintassi ES6 e ES7 in modo che sia conforme allo standard ES5.

\subsection{Componenti esterni}

React Native supporta la gestione dei moduli secondo lo standard CommonJS\footnote{http://requirejs.org/docs/commonjs.html}, questo permette di utilizzare npm per la gestione delle dipendenze con i componenti esterni.

Sfruttando le possibilità offerte da npm, la community di sviluppatori ha già iniziato a pubblicare alcuni componenti per le applicazioni di React Native, che possono essere facilmente integrati nella propria applicazione.
Una raccolta di questi componenti può essere trovata sul sito React Parts\footnote{\url{https://react.parts/native-ios}}, il qualche contiene componenti sia per React che per React Native.

\section{Flux}\label{sec:flux}
Flux è un pattern architetturale per le applicazioni sviluppate con React e React Native proposto da Facebook.

Questo pattern sfrutta il sistema di composizione delle view di React costruendo un flusso di dati unidirezionale, che a partire da un oggetto \textit{store} diventano lo stato di un oggetto \textit{view-controller}, che a sua volta li fornisce ai propri componenti.

L'unico modo per modificare i dati presenti in uno \textit{store} è mediante un \textit{action}, quando un \textit{view-controller} vuole modificare i dati a seguito di un evento scatenato dall'utente, crea un \textit{action} che, mediante un \textit{dispatcher}, viene ricevuto dai vari \textit{store} dell'applicazione.

\begin{figure}[htp]
\centering
\includegraphics[width=\textwidth*3/4]{../immagini/flux-simple}
\caption{Diagramma del pattern Flux}  
\end{figure}
\FloatBarrier

Come anticipato, Flux prevede tre tipologie principali di componenti:
\begin{itemize}
\item \textbf{Stores:} sono dei \textit{singleton} che contengono i dati dell'applicazione, forniscono solamente dei metodi \textit{getter}, per interagire con i dati contenuti è necessario usare le \textit{actions}.
\item \textbf{Actions:} sono degli oggetti che contengono delle informazioni riguardante alle varie operazioni che possono eseguite dagli \textit{stores} dell'applicazione. Tipicamente vengono create dai \textit{view-controller} di React e contengono già i dati necessari agli \textit{store} per aggiornarsi, nel caso di operazioni asincrone i \textit{view-controller} creano l'azione che verrà comunicata al \textit{dispatcher} solamente quando sono stati caricati i dati.
\item \textbf{Dispatcher:} oggetto che riceve un \textit{action} e ne esegue il broadcast verso tutti gli \textit{stores} registrati dell'applicazione. Fornisce delle funzionalità che permettono ai vari \textit{stores} di registrarsi e di specificare eventuali dipendenze verso altri \textit{stores} dell'applicazione in modo che l'aggiornamento di un determinato \textit{store} venga effettuato una volta completato l'aggiornamento degli \textit{stores} da cui dipende, evitando così di ottenere uno stato inconsistente.
\end{itemize}


\subsection{Sequenza delle azioni}

\begin{figure}[htp]
\centering
\includegraphics[width=\textwidth*3/4]{../immagini/flux-diagram}
\caption{Funzionamento del pattern Flux}  
\end{figure}
\FloatBarrier

\begin{enumerate}
\item L'utente esegue un'azione sulla view.
\item Il gestore dell'evento crea un \textit{action} e la comunica al \textit{dispatcher}.
\item Il \textit{dispatcher} manda a tutti gli \textit{stores} registrati l'oggetto \textit{action} ricevuto.
\item Ogni \textit{store} esamina l'oggetto  \textit{action} e se necessario si aggiorna. 
\item Gli \textit{stores} che hanno subito modifiche emettono un evento per comunicare ai componenti React in ascolto che si devono aggiornare.
\item I componenti React richiedono agli \textit{stores} i dati per aggiornarsi.
\end{enumerate}

\subsection{Differenze con MVC}

Nonostante Flux ed MVC possano sembrare due pattern totalmente diversi, in realtà Flux è una variante del MVC classico con delle modifiche che lo adattano al funzionamento di React e React Native.

Infatti, con MVC, i \textit{controllers} interagiscono con il \textit{model} e le \textit{view} dell'applicazione visualizzano i dati presenti al suo interno.
Quando il \textit{model} viene modificato, le \textit{view} vengono notificate e recuperano i dati aggiornati dal model.

Mentre con Flux, i \textit{view-controller} aggiornano il model, definito dagli \textit{stores}, in un modo più strutturato utilizzando le \textit{actions} e, una volta che l'aggiornamento degli \textit{store} è completato, i \textit{view-controller} vengono notificati in modo che possano recuperare i nuovi dati.

Considerando che per React e React Native una \textit{view} e il relativo \textit{controller} sono lo stesso oggetto diventa chiaro che la logica di base è la stessa, l'unica differenza è come viene effettuato l'aggiornamento dei dati, che con Flux deve passare attraverso delle \textit{actions}.

Questo vincolo imposto dall'utilizzo delle \textit{actions} permette di circoscrivere la logica di aggiornamento del model all'interno del model stesso, limitando la complessità dell'applicazione, che nel caso di grandi applicazioni può diventare ingestibile.

Un altro vantaggio che viene dall'adozione di Flux con React riguarda l'aggiornamento dell'interfaccia grafica a seguito di una modifica dei dati, in quanto sia React che Flux ragionano a stati: con React l'interfaccia grafica visualizza uno stato dell'applicazione, il cambiamento dello stato comporta il re-rendering dell'interfaccia, mentre con Flux l'insieme degli \textit{stores} rappresenta lo stato dell'applicazione e l'esecuzione di un'azione comporta il cambiamento dello stato.

Di conseguenza è possibile collegare direttamente lo stato definito dagli \textit{stores}, con lo stato dei componenti grafici, limitando il numero di operazioni intermedie.

\subsection{flux}\label{sec:flux-npm}

\texttt{flux} è un modulo pubblicato su npm da Facebook che fornisce delle classi che aiutano nell'implementazione di Flux.
Tra queste classi è presente l'implementazione completa di un \textit{dispatcher} e una classe base per la creazione degli \textit{stores} che si occupa di implementare tutta la parte relativa alla registrazione e pubblicazioni degli eventi legati all'aggiornamento dei dati.

\section{React Native CLI}\label{sec:packager}

React Native è dotato di un'interfaccia a riga di comando che può essere installata via npm e che comprende una serie di tool per lo sviluppo di supporto allo sviluppo delle applicazioni.

In particolare contiene il \textit{packager}, un programma che permette di creare dei bundle JavaScript contenenti il codice dell'applicazione.

Quando richiesto, il\textit{packager} esegue la conversione da JSX in JavaScript, trasformando anche il JavaScript ES6 in JavaScript ES5, e successivamente crea il bundle, unendo tutti i file JavaScript necessari al funzionamento dell'applicazione.

Il bundle deve poi essere aggiunto al progetto Xcode in modo che sia disponibile sul dispositivo.

Durante lo sviluppo di un'applicazione è inoltre possibile configurare il progetto Xcode in modo che recuperi il bundle JavaScript dell'applicazione da un server presente sul computer con il quale si sta sviluppando.
Così facendo è possibile eseguire ogni volta il codice aggiornato senza dover reinstallare l'applicazione sul dispositivo o sul simulatore.
L'avvio e la gestione di questo server viene gestita in modo automatico dai tools che vengono installati con l'interfaccia a riga di comando.

\section{Atom e Nuclide}

L'editor di testo prescelto per la sviluppo di un'applicazione con React Native è Atom\footnote{https://atom.io/}, un editor open source sviluppato di GitHub, che può essere personalizzato mediante dei pacchetti.

\`E stato scelto Atom perché Facebook ha rilasciato Nuclide\url{http://nuclide.io/}, una serie di pacchetti da installare su Atom che aggiungo alcune funzionalità di supporto allo sviluppo con React Native, come l'auto-completamento delle keyword e l'evidenziazione della sintassi JSX.

\section{Xcode}

Nonostante il codice JavaScript possa essere scritto con qualsiasi editor di testo, è necessario utilizzare Xcode per compilare l'applicazione finale in modo da poterla installare sul simulatore di iOS o su un dispositivo Apple.

Xcode rende disponibili un serie di tools per lo sviluppo delle applicazioni native che possono essere riutilizzati durante lo sviluppo di un'applicazione con React Native. Ad esempio durante l'esecuzione dell'applicazione sul simulatore di iOS è possibile controllare il consumo della memoria, il traffico dati e l'utilizzo della CPU.

\begin{figure}[htp]
\centering
\includegraphics[width=\textwidth]{../immagini/xcode-tools}
\caption{Tools di debug di Xcode}  
\end{figure}
\FloatBarrier

\section{Google Chrome Dev Tools}

Durante lo sviluppo di un'applicazione con React Native è possibile utilizzare i developers tool di Google Chrome per effettuare il debug del codice JavaScript.

In particolare è possibile utilizzare il debugger di Chrome per effettuare inserire dei break point nel codice dell'applicazione ed effettuare l'esecuzione passo passo del codice, oppure è possibile stampare sulla console di Chrome mediante \texttt{console.log}.

Al momento non è possibile utilizzare tutti i tools in quanto la modalità debug di React Native modifica la virtual machine che esegue JavaScript.

Infatti, durante l'esecuzione normale il JavaScript viene interpretato da JavaScriptCore, mentre, durante il debug, viene utilizzata la virtual machine V8 presente all'interno di Chrome, al quale comunica con l'applicazione nativa mediante WebSocket.

In questo modo Chrome riesce a controllare l'esecuzione del JavaScript, ma non riesce ad accedere alle funzionalità che vengono eseguite dai componenti nativi, come l'utilizzo delle risorse di rete o la gestione della memoria.

\begin{figure}[htp]
\centering
\includegraphics[width=\textwidth]{../immagini/chrome-tools}
\caption{Debug di un'applicazione con Google Chrome}  
\end{figure}

